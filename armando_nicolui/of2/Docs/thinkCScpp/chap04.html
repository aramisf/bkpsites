<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Chapter 4: Conditionals and recursion</title>

<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
</style>


<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style>

</head>

<body>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">
  <tr>
    <td width="20" class=head><a href="chap05.html"><img border="0" alt="Next" src="images/next.png"></a></td>
    <td width="20" class=head><a href="index.html"><img border="0" alt="Up" src="images/up.png"></a></td>
    <td width="20" class=head><a href="chap03.html"><img border="0" alt="Previous" src="images/prev.png"></a></td>
    <td width="100%" class=headcenter><img border="0" alt="Hi" src="images/headertitle.png"></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png"></td>
    <td width="20" class=head><a href="dex.html"><img border="0" alt="Index" src="images/index.png"></a></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png"></td>
  </tr>
</table>
<hr>


<h2>Chapter 4</h2>

<h1>Conditionals and recursion</h1>


<a name=1></a><br>
<h3>4.1 The modulus operator</h3>

<p>The modulus operator works on integers (and integer expressions) and yields the <i>remainder</i> when the first operand is divided by the second.  In C++, the modulus operator is a percent sign, <span class=code>%</span>.  The syntax is exactly the same as for other operators:</p>


<span class=code>&nbsp; <span class=keyword>int</span> quotient = 7 / 3;
<br>&nbsp; <span class=keyword>int</span> remainder = 7 % 3;
<br></span><p>The first operator, integer division, yields 2.  The second operator yields 1.  Thus, 7 divided by 3 is 2 with 1 left over.</p>

<p>The modulus operator turns out to be surprisingly useful.  For example, you can check whether one number is divisible by another: if <span class=code>x % y</span> is zero, then <span class=code>x</span> is divisible by <span class=code>y</span>.</p>

<p>Also, you can use the modulus operator to extract the rightmost digit or digits from a number.  For example, <span class=code>x % 10</span> yields the rightmost digit of <span class=code>x</span> (in base 10).  Similarly <span class=code>x % 100</span> yields the last two digits.</p>

<a name=2></a><br>
<h3>4.2 Conditional execution</h3>

<p>In order to write useful programs, we almost always need the ability to check certain conditions and change the behavior of the program accordingly.  <b>Conditional statements</b> give us this ability.  The simplest form is the <span class=code><span class=keyword>if</span></span> statement:</p>


<span class=code>&nbsp; <span class=keyword>if</span> (x &gt; 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is positive"</span> &lt;&lt; endl;
<br>&nbsp; }
<br></span><p>The expression in parentheses is called the condition. If it is true, then the statements in brackets get executed. If the condition is not true, nothing happens.</p>



<p>The condition can contain any of the <span class=code>comparison operators</span>:</p>


<span class=code>&nbsp; &nbsp; x == y&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=comment>// x equals y
</span><br>&nbsp; &nbsp; x != y&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=comment>// x is not equal to y
</span><br>&nbsp; &nbsp; x &gt; y&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=comment>// x is greater than y
</span><br>&nbsp; &nbsp; x &lt; y&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=comment>// x is less than y
</span><br>&nbsp; &nbsp; x &gt;= y&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=comment>// x is greater than or equal to y
</span><br>&nbsp; &nbsp; x &lt;= y&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=comment>// x is less than or equal to y
</span><br></span><p>Although these operations are probably familiar to you, the syntax C++ uses is a little different from mathematical symbols like <tt>=</tt>, <tt>neq</tt> and <tt>le</tt>.  A common error is to use a single <span class=code>=</span> instead of a double <span class=code>==</span>.  Remember that <span class=code>=</span> is the assignment operator, and <span class=code>==</span> is a comparison operator.  Also, there is no such thing as <span class=code>=&lt;</span> or <span class=code>=&gt;</span>.</p>

<p>The two sides of a condition operator have to be the same type.  You can only compare <span class=code>ints</span> to <span class=code>ints</span> and <span class=code>doubles</span> to <span class=code>doubles</span>.  Unfortunately, at this point you can't compare <span class=code>String</span>s at all!  There is a way to compare <span class=code>String</span>s, but we won't get to it for a couple of chapters.</p>

<a name=3></a><br>
<h3>4.3 Alternative execution</h3>

<p>A second form of conditional execution is alternative execution, in which there are two possibilities, and the condition determines which one gets executed.  The syntax looks like:</p>


<span class=code>&nbsp; <span class=keyword>if</span> (x%2 == 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is even"</span> &lt;&lt; endl;
<br>&nbsp; } <span class=keyword>else</span> {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is odd"</span> &lt;&lt; endl;
<br>&nbsp; }
<br></span><p>If the remainder when <span class=code>x</span> is divided by 2 is zero, then we know that <span class=code>x</span> is even, and this code displays a message to that effect.  If the condition is false, the second set of statements is executed.  Since the condition must be true or false, exactly one of the alternatives will be executed.</p>

<p>As an aside, if you think you might want to check the parity (evenness or oddness) of numbers often, you might want to "wrap" this code up in a function, as follows:</p>


<span class=code><span class=keyword>void</span> printParity (<span class=keyword>int</span> x) {
<br>&nbsp; <span class=keyword>if</span> (x%2 == 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is even"</span> &lt;&lt; endl;
<br>&nbsp; } <span class=keyword>else</span> {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is odd"</span> &lt;&lt; endl;
<br>&nbsp; }
<br>}
<br></span><p>Now you have a function named <span class=code>printParity</span> that will display an appropriate message for any integer you care to provide. In <span class=code>main</span> you would call this function as follows:</p>


<span class=code>&nbsp; &nbsp; printParity (17);
<br></span><p>Always remember that when you <i>call</i> a function, you do not have to declare the types of the arguments you provide. C++ can figure out what type they are.  You should resist the temptation to write things like:</p>


<span class=code>&nbsp; <span class=keyword>int</span> number = 17;
<br>&nbsp; printParity (<span class=keyword>int</span> number);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=comment>// WRONG!!!
</span><br></span><a name=4></a><br>
<h3>4.4 Chained conditionals</h3>

<p>Sometimes you want to check for a number of related conditions and choose one of several actions.  One way to do this is by <b>chaining</b> a series of <span class=code><span class=keyword>if</span></span>s and <span class=code><span class=keyword>else</span></span>s:</p>


<span class=code>&nbsp; <span class=keyword>if</span> (x &gt; 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is positive"</span> &lt;&lt; endl;
<br>&nbsp; } <span class=keyword>else if</span> (x &lt; 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is negative"</span> &lt;&lt; endl;
<br>&nbsp; } <span class=keyword>else</span> {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is zero"</span> &lt;&lt; endl;
<br>&nbsp; }
<br></span><p>These chains can be as long as you want, although they can be difficult to read if they get out of hand.  One way to make them easier to read is to use standard indentation, as demonstrated in these examples.  If you keep all the statements and squiggly-braces lined up, you are less likely to make syntax errors and you can find them more quickly if you do.</p>

<a name=5></a><br>
<h3>4.5 Nested conditionals</h3>

<p>In addition to chaining, you can also nest one conditional within another.  We could have written the previous example as:</p>


<span class=code>&nbsp; <span class=keyword>if</span> (x == 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is zero"</span> &lt;&lt; endl;
<br>&nbsp; } <span class=keyword>else</span> {
<br>&nbsp; &nbsp; <span class=keyword>if</span> (x &gt; 0) {
<br>&nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is positive"</span> &lt;&lt; endl;
<br>&nbsp; &nbsp; } <span class=keyword>else</span> {
<br>&nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class=quote>"x is negative"</span> &lt;&lt; endl;
<br>&nbsp; &nbsp; }
<br>&nbsp; }
<br></span><p>There is now an outer conditional that contains two branches.  The first branch contains a simple output statement, but the second branch contains another <span class=code><span class=keyword>if</span></span> statement, which has two branches of its own.  Fortunately, those two branches are both output statements, although they could have been conditional statements as well.</p>

<p>Notice again that indentation helps make the structure apparent, but nevertheless, nested conditionals get difficult to read very quickly.  In general, it is a good idea to avoid them when you can.</p>



<p>On the other hand, this kind of <b>nested structure</b> is common, and we will see it again, so you better get used to it.</p>

<a name=6></a><br>
<h3>4.6 The <span class=code><span class=keyword>return</span></span> statement</h3>

<p>The <span class=code><span class=keyword>return</span></span> statement allows you to terminate the execution of a function before you reach the end.  One reason to use it is if you detect an error condition:</p>


<span class=code>#include &lt;math.h&gt;
<br>
<br><span class=keyword>void</span> printLogarithm (<span class=keyword>double</span> x) {
<br>&nbsp; <span class=keyword>if</span> (x &lt;= 0.0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"Positive numbers only, please."</span> &lt;&lt; endl;
<br>&nbsp; &nbsp; <span class=keyword>return</span>;
<br>&nbsp; }
<br>
<br>&nbsp; <span class=keyword>double</span> result = log (x);
<br>&nbsp; cout &lt;&lt; <span class=quote>"The log of x is "</span> &lt;&lt; result);
<br>}
<br></span><p>This defines a function named <span class=code>printLogarithm</span> that takes a <span class=code><span class=keyword>double</span></span> named <span class=code>x</span> as a parameter.  The first thing it does is check whether <span class=code>x</span> is less than or equal to zero, in which case it displays an error message and then uses <span class=code><span class=keyword>return</span></span> to exit the function.  The flow of execution immediately returns to the caller and the remaining lines of the function are not executed.</p>

<p>I used a floating-point value on the right side of the condition because there is a floating-point variable on the left.</p>

<p>Remember that any time you want to use one a function from the math library, you have to include the header file <span class=code>math.h</span>.</p>

<a name=7></a><br>
<h3>4.7 Recursion</h3>

<p>I mentioned in the last chapter that it is legal for one function to call another, and we have seen several examples of that.  I neglected to mention that it is also legal for a function to call itself.  It may not be obvious why that is a good thing, but it turns out to be one of the most magical and interesting things a program can do.</p>

<p>For example, look at the following function:</p>


<span class=code><span class=keyword>void</span> countdown (<span class=keyword>int</span> n) {
<br>&nbsp; <span class=keyword>if</span> (n == 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; <span class=quote>"Blastoff!"</span> &lt;&lt; endl;
<br>&nbsp; } <span class=keyword>else</span> {
<br>&nbsp; &nbsp; cout &lt;&lt; n &lt;&lt; endl;
<br>&nbsp; &nbsp; countdown (n-1);
<br>&nbsp; }
<br>}
<br></span><p>The name of the function is <span class=code>countdown</span> and it takes a single integer as a parameter.  If the parameter is zero, it outputs the word "Blastoff."  Otherwise, it outputs the parameter and then calls a function named <span class=code>countdown</span>---itself---passing <span class=code>n-1</span> as an argument.</p>

<p>What happens if we call this function like this:</p>


<span class=code><span class=keyword>void</span> main ()
<br>{
<br>&nbsp; countdown (3);
<br>}
<br></span><p>The execution of <span class=code>countdown</span> begins with <span class=code>n=3</span>, and since <span class=code>n</span> is not zero, it outputs the value 3, and then calls itself...</p>

<p style="margin-left: 30px; margin-right: 30px;"> The execution of <span class=code>countdown</span> begins with <span class=code>n=2</span>, and since <span class=code>n</span> is not zero, it outputs the value 2, and then calls itself...

<p style="margin-left: 30px; margin-right: 30px;"> The execution of <span class=code>countdown</span> begins with <span class=code>n=1</span>, and since <span class=code>n</span> is not zero, it outputs the value 1, and then calls itself...

<p style="margin-left: 30px; margin-right: 30px;"> The execution of <span class=code>countdown</span> begins with <span class=code>n=0</span>, and since <span class=code>n</span> is zero, it outputs the word "Blastoff!" and then returns. </p>

<p>The countdown that got <span class=code>n=1</span> returns.</p>

</p>

<p>The countdown that got <span class=code>n=2</span> returns.</p>

</p>

<p>The countdown that got <span class=code>n=3</span> returns.</p>

<p>And then you're back in <span class=code>main</span> (what a trip).  So the total output looks like:</p>


<span class=code>3
<br>2
<br>1
<br>Blastoff!
<br></span><p>As a second example, let's look again at the functions <span class=code>newLine</span> and <span class=code>threeLine</span>.</p>


<span class=code><span class=keyword>void</span> newLine () {
<br>&nbsp; cout &lt;&lt; endl;
<br>}
<br>
<br><span class=keyword>void</span> threeLine () {
<br>&nbsp; newLine ();&nbsp; newLine ();&nbsp; newLine ();
<br>}
<br></span><p>Although these work, they would not be much help if I wanted to output 2 newlines, or 106.  A better alternative would be</p>


<span class=code><span class=keyword>void</span> nLines (<span class=keyword>int</span> n) {
<br>&nbsp; <span class=keyword>if</span> (n &gt; 0) {
<br>&nbsp; &nbsp; cout &lt;&lt; endl;
<br>&nbsp; &nbsp; nLines (n-1);
<br>&nbsp; }
<br>}
<br></span><p>This program is similar to <span class=code>countdown</span>; as long as <span class=code>n</span> is greater than zero, it outputs one newline, and then calls itself to output <span class=code>n-1</span> additional newlines.  Thus, the total number of newlines is <span class=code>1 + (n-1)</span>, which usually comes out to roughly <span class=code>n</span>.</p>



<p>The process of a function calling itself is called <b>recursion</b>, and such functions are said to be <b>recursive</b>.</p>

<a name=8></a><br>
<h3>4.8 Infinite recursion</h3>

<p>In the examples in the previous section, notice that each time the functions get called recursively, the argument gets smaller by one, so eventually it gets to zero.  When the argument is zero, the function returns immediately, <i>without making any recursive calls</i>. This case---when the function completes without making a recursive call---is called the <b>base case</b>.</p>

<p>If a recursion never reaches a base case, it will go on making recursive calls forever and the program will never terminate.  This is known as <b>infinite recursion</b>, and it is generally not considered a good idea.</p>



<p>In most programming environments, a program with an infinite recursion will not really run forever.  Eventually, something will break and the program will report an error.  This is the first example we have seen of a run-time error (an error that does not appear until you run the program).</p>

<p>You should write a small program that recurses forever and run it to see what happens.</p>

<a name=9></a><br>
<h3>4.9 Stack diagrams for recursive functions</h3>

<p>In the previous chapter we used a stack diagram to represent the state of a program during a function call.  The same kind of diagram can make it easier to interpret a recursive function.</p>

<p>Remember that every time a function gets called it creates a new instance that contains the function's local variables and parameters.</p>

<p>This figure shows a stack diagram for countdown, called with <span class=code>n = 3</span>:</p>

<p align="center"><img src="images/stack2.png"></p>

<p>There is one instance of <span class=code>main</span> and four instances of <span class=code>countdown</span>, each with a different value for the parameter <span class=code>n</span>.  The bottom of the stack, <span class=code>countdown</span> with <span class=code>n=0</span> is the base case.  It does not make a recursive call, so there are no more instances of <span class=code>countdown</span>.</p>

<p>The instance of <span class=code>main</span> is empty because <span class=code>main</span> does not have any parameters or local variables.  As an exercise, draw a stack diagram for <span class=code>nLines</span>, invoked with the parameter <span class=code>n=4</span>.</p>

<a name=10></a><br>
<h3>4.10 Glossary</h3>

<dl>

<dt>modulus</dt>
<dd>An operator that works on integers and yields the remainder when one number is divided by another.  In C++ it is denoted with a percent sign (<span class=code>%</span>).</dd>

<dt>conditional</dt>
<dd>A block of statements that may or may not be executed depending on some condition.</dd>

<dt>chaining</dt>
<dd>A way of joining several conditional statements in sequence.</dd>

<dt>nesting</dt>
<dd>Putting a conditional statement inside one or both branches of another conditional statement.</dd>

<dt>recursion</dt>
<dd>The process of calling the same function you are currently executing.</dd>

<dt>infinite recursion</dt>
<dd>A function that calls itself recursively without every reaching the base case.  Eventually an infinite recursion will cause a run-time error.</dd>



</dl>

<p>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">
  <tr>
    <td width="20" class=head><a href="chap05.html"><img border="0" alt="Next" src="images/next.png"></a></td>
    <td width="20" class=head><a href="index.html"><img border="0" alt="Up" src="images/up.png"></a></td>
    <td width="20" class=head><a href="chap03.html"><img border="0" alt="Previous" src="images/prev.png"></a></td>
    <td width="100%" class=headcenter><img border="0" alt="Hi" src="images/headertitle.png"></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png"></td>
    <td width="20" class=head><a href="dex.html"><img border="0" alt="Index" src="images/index.png"></a></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png"></td>
  </tr>
</table>
<hr>

</body>
</html>
